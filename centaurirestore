#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2017-2025; BSD License"
CEN_TITLE=$"Restore a centauribackup, optionally rename an existing machine"

PATH+=":${0%/*}" . _centauri_bash_lib -a -d -m bat -m con -r -t -y - '0.61:6' || exit 2

# Options

CEN_OPT_BOOT=           # see --boot
CEN_OPT_CLONE=          # see --clone
CEN_OPT_DIST=           # see --dist
CEN_OPT_LABEL=          # see --label
CEN_OPT_FORMAT=         # fs2fs|ext4 default=brtfs
CEN_OPT_PART=           # root partition, see --partion
CEN_OPT_SWAP=           # swap partition, see --swap
CEN_OPT_GRUB=
CEN_OPT_IMAGE=          # use image file, see --image
CEN_OPT_RESTORE=        # see --restore
CEN_OPT_EXTRACT=        # see --extract

# Data

DAT_DISPATCH=           # dispatch() main action
DAT_HOOK_QUIT=          # quit hook, see do_unmount

DAT_CLONE_ORIG=         # see do_clone TODO remove
DAT_ROOT_CLONE=         # root clone flag
DAT_BOOT_CLONE=         # boot clone flag

DAT_DEST_ROOT=          # destination path: Root
DAT_DEST_USER=          # ... Root/usr
DAT_DEST_HOME=          # ... Home
DAT_DEST_BOOT=          # ... systemd efi or firmware

DAT_FILE_BOOT=          # boot data tar file

DAT_LOOPDEV=            # losetup of CEN_OPT_IMAGE

CEN_DAT_DOMAIN=         # from --clone TODO never set
DAT_PART_LABEL=         # root label, see do_label()
DAT_SWAP_LABEL=         # swap label, see do_label()
DAT_RUN_FIXUP=          # run do_fixup once flag
DAT_FMT_VFAT='vfat'
                        # call 'dispatch -r' instead of 'run'
CEN_HOOK_RUN='dispatch -r'
                        # don't let tar use id names
DAT_TAR_OPTS='--numeric-owner'
                        # minimal bios grub config
DAT_GRUB_MINIMAL="$CEN_TOOLS/templates/grub-minimal-cfg"

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

# check a restore file argument: <vnam> <file> [<dflt> <patn>]
do_chk_file() {
    local _file="${2:-+}"
    if [ "$_file" = '+' ] ; then
        [ "${4:--}" = '-' ] && _file='-' || _file="${4/::::/$3}"
    fi
    if [ "$_file" = '-' ] ; then
        printf -v "$1" '-' ; return 1
    fi

    prettypath -c -s "$1" -- "$_file"
    [ -r "$_file" ] && return 0
    error $"Cannot read file:" "$_file"
}

# check for writable block device: <device>
do_chk_block() {
    if [ ! -b "$1" ] ; then
        error $"Not a block device:" "$1"
    elif [ ! -w "$1" ] ; then
        error $"Cannot write to:" "$1"
    else
        return 0
    fi
    return 1
}

# check swap partition
do_chk_swap() {
    [ "${CEN_OPT_SWAP:--}" = '-' ] && return 0
    [ "${CEN_OPT_SWAP::1}" = '/' ] || CEN_OPT_SWAP="/dev/${CEN_OPT_SWAP#/dev/}"
    do_chk_block "$CEN_OPT_SWAP"              # return status
}

# ------------------------------------------------------------------------------
# rename the computer: [<boot>|-] <root>|-
#
#   if we have [boot] ignore - <boot>
#   try to find [boot] if we have root
#
# ------------------------------------------------------------------------------
do_clone() {
    local dboot="${1:--}" droot="${2:--}" name="${CEN_OPT_CLONE:--}" curr="$PWD"

    # do_clone_boot should set a flag and ingnore 2nd call

    [ "$name" = '-' ] && return
    [ "$name" = '-' ] && name="${DAT_PART_LABEL##*/}" && name="${name%%[_-]*}"
    [ -z "$name" ] && quit -e $"Don't know new name, cannot rename"

    [ -n "$DAT_ROOT_CLONE" ] && droot='-'           # run 1 time only
    [ "$droot" != '-' ] && folder -c -- "$droot" && do_clone_root "$name"
    [ "$name" = '+' ] && dboot='-'                  # new machine id

    [ -n "$DAT_BOOT_CLONE" ] && dboot='-'           # run 1 time only
    [ "$dboot" != '-' ] && folder -c -- "$dboot" && do_clone_boot "$name"
    folder -c -- "$curr"

    # update grub/loader and fstab
    error -t || return
    [ "$dboot" != '-' -o "$droot" != '-' ] && do_update "$dboot" "$droot" "$name"
}

do_clone_boot() {
    DAT_BOOT_CLONE=1                                # only run once
    local name="$1"
    # this code runs after do_clone_boot, so use the save current name
    if [ "$DAT_CLONE_ORIG" = "$name" ] ; then
        trace -a -p $"The machine name is '%s', no rename" "$name"
        return 0
    fi
    do_marker '.' 'boot'
}

do_clone_root() {
    DAT_ROOT_CLONE=1                                # only run once
    [ -z "$CEN_OPT_DRYRUN" -a ! -d 'etc' ] &&
        quit -e $"No '/etc' folder, cannot rename"

    if [ "$name" = '+' ] ; then
        confirm -a $"Generate a new machine-id" || quit -t
        do_fixup                                    # fix missing things
        do_machine_id ; return
    fi

    local item orig='<unknown>' name="$1"
    readline -w -s DAT_CLONE_ORIG -x -i 'etc/hostname'
    if [ "$DAT_CLONE_ORIG" = "$name" ] ; then
        trace -a -p $"The machine name is '%s', no rename" "$name"
        return 0
    else
        confirm -a $"Rename machine:" "$DAT_CLONE_ORIG => $name" || quit -t
    fi
    if [ -d 'Volumes' ] ; then
        do_marker "Volumes/Root"
        do_marker "Volumes/Home" 'home'
        do_marker '.' 'vol0'
    else
        do_marker '.'
        do_marker 'home' 'home'
    fi
    do_fixup                                        # fix missing things
    do_machine_id
    error -t || return

    confirm -n -b $"Generate new ssh host keys" &&
        embed -i -v centaurikeys -y -q hostkeys 'etc/ssh'

    # remove persistent device names (legacy)
    remove 'etc/udev/rules.d/'*-persistent-*
    # remove name override
    remove 'etc/sysctl.d/host+domain.conf'

    # clean dhcp and samba caches
    remove 'var/lib/dhcp'/*
    remove 'var/lib/samba/wins.dat' 'var/cache/samba/browse.dat'
    error -t || return

    # generate network configuration
    local conf="${CEN_DEFAULT:1}/centaurinetcfg"
    if [ -e "$conf" ] ; then
        [ -n "$CEN_DAT_DOMAIN" ] && full="$name.$CEN_DAT_DOMAIN" || full="$name"
        trace -a $"Update network configuration:" "$full"
        [ "$PWD" -ef '/' ] && orig= || orig='--output=.'
        embed -i -v centaurinetcfg $orig "--config=$conf" setup "$full"
    else
        create -t -v name -- 'etc/hostname' 644
        trace -a $"No 'centaurinetcfg', skip network configuration"
    fi
    error -t || return

    # create resume
    do_label "$name"
    if [ -d 'etc/initramfs-tools/conf.d' ] ; then
        if [ -z "$CEN_OPT_DRYRUN" ] ; then
            item="resume=LABEL=$DAT_SWAP_LABEL"
            create -t -v item -- 'etc/initramfs-tools/conf.d/resume'
            message -a $"Run 'update-initramfs -u' manually to make hibernate work"
        fi
    fi
}

# ------------------------------------------------------------------------------
# get target folder for --boot|--grub|--restore|--extract
# ------------------------------------------------------------------------------
do_destination() {
    if [ "${1::5}" = '/dev/' ] ; then
        do_chk_block "$1" || return
### TODO still needed?
DAT_DEST_ROOT=          # destination path: Root
DAT_DEST_USER=          # ... Root/usr
DAT_DEST_HOME=          # ... Home
DAT_DEST_BOOT=          # ... systemd efi or firmware
        usermount -e -b -o progress -r -s DAT_DESTINATION -- "$1"
        return                                      # return status
    fi
    folder -s DAT_DESTINATION -- "$1"               # return status
}

# ------------------------------------------------------------------------------
# create required /dev entries and folders
# ------------------------------------------------------------------------------
do_fixup() {
    [ -n "$DAT_RUN_FIXUP" ] && return
    message -a $"Check/create required folders"
    DAT_RUN_FIXUP=1

    # make /tmp a symlink if missing
    [ -d 'tmp' ] || symlink -m '/dev/shm' 'tmp'

    # in case that udev is not used
    if [ -d 'dev' ] ; then
        [ -e 'dev/console' ] || system -e -p mknod -m 660 'dev/console' c 5 1
        [ -e 'dev/null'    ] || system -e -p mknod -m 660 'dev/null'    c 1 3
    fi

    system -e -p chmod 755 '.'
    attributes -d -k -m 755 -- 'dev' 'proc' 'sys' 'var' 'var/lib'
    attributes -d -k -m 755 -o root:wheel -- 'var/lib/centauri'

    # fix apt permissions (same code as in centaurisecurity)
    if [ -d 'var/lib/apt' ] ; then
        attributes -d -m 755 -o root:root -- 'var/lib/apt/lists'         'var/cache/apt/archives'
        attributes -d -m 700 -o _apt:root -- 'var/lib/apt/lists/partial' 'var/cache/apt/archives/partial'
    fi
}

# ------------------------------------------------------------------------------
# handle formatting and labelling: <part> <type> <suff> [+]
# ------------------------------------------------------------------------------
do_format() {
    [ -z "$1" ] && return
    local part="$1" type="$2" labl
    case "$part" in
    /dev/*) ;;
    /img/?) part="${DAT_LOOPDEV}p${part:5}" ;;
    *)      quit -e $"Formatting needs a partition name:" "$part"
    esac
    do_chk_block "$part"
    findmount "$part" && quit $"Partition must not be mounted:" "$part"
    if [ "${CEN_OPT_LABEL:--}" = '-' ] ; then
         [ -z "$4" ] && labl=$"-none-"
    else
        labl="$DAT_PART_LABEL"
        [ "$3" = 'root' ] || labl="${labl%_*}_$3"
    fi

    local args=("mkfs.$2")
    case "$2" in
    f2fs)   [ -n "$labl" ] && args+=(-l "$labl") ; args+=(-f) ;;
    ext4)   args+=(-O dir_index)        # tune2fs -c0 -i0
            [ -n "$labl" ] && args+=(-L "$labl") ;;
    btrfs)  [ -n "$labl" ] && args+=(-L "$labl") ; args+=(-f) ;;
    *)      [ -n "$labl" ] && args+=(-n "$labl")
            if [ "${#labl}" -gt 11 ] ; then
                do_prefix ; labl="${DAT_PREFIX}_${labl##*_}"
                trace -a $"VFAT label too long, using random prefix"
            fi
    esac

    if [ -z "$4" ] ; then
        message -a -p $"Going to format %12s  as %-8s  label %s" "'$part'" "'$2'" "'$labl'"
        return
    fi

    # --- format ---

    [ -n "$labl" ] && message -a -p $"Will label %s partition as: %s" "$3" "$labl"
    system -e -p -g 0 -- ${args[@]} "$part" || return
    [ "$3" = 'root' ] || return 0

    # --- extra steps for root partition ---

    if [ "$2" = 'ext4' ] ; then
        message -a $"Disable ext4 disk checks ..."
        system -e -p tune2fs -c0 -i0 "$part"
    elif [ "$2" = 'btrfs' ] ; then
        message -a $"Create btrfs subvolumes ..."
        do_destination "$part" || return
        folder -m "$DAT_DESTINATION/Volumes" || return
        folder -m "$DAT_DESTINATION/Snapshots" || return
        local item vols="$DAT_DESTINATION/Volumes"
        for item in 'Root' 'Home' 'Export' 'Shared' 'Backup' ; do
            system -e -p -g 0 -- btrfs subvolume create "$vols/$item" || return
        done
        folder -m "$vols/Backup/disk" || return
        folder -m "$vols/Backup/data" || return

        system -e -p -a args -d '\n' btrfs subvolume list -t "$DAT_DESTINATION" || return
        for item in "${args[@]}" '' ; do
            set -f ; set -- $item ; set +f
            [ "${4##*/}" = 'Root' ] && break
        done
        if [ -z "$1" ] ; then
            warning $"Cannot set default volume"
        else
            system -e -p -g 0 -- btrfs subvolume set-default \
                                       "$1" "$DAT_DESTINATION" || return
        fi
        # location() uses '/dev' to identify a root volume
        folder -m "$vols/Root/dev" || return
    fi

    if [ "$2" != 'btrfs' ] ; then
        do_destination "$part" || return
        # location() uses '/dev' to identify a root volume
        folder -m "$DAT_DESTINATION/dev" || return
    fi
    return 0
}

# ------------------------------------------------------------------------------
# determine swap/root labels: <archive>
# ------------------------------------------------------------------------------
do_label() {
    # implicit label: see --name and archive
    [ -z "$CEN_OPT_LABEL" ] && CEN_OPT_LABEL="$CEN_OPT_CLONE"
    [ -z "$CEN_OPT_LABEL" ] && CEN_OPT_LABEL="${1##*/}" && CEN_OPT_LABEL="${CEN_OPT_LABEL%%[_-]*}"
    [ "${CEN_OPT_LABEL:--}" = '-' ] && return          # no labels

    local sufi='root'
    [ "$CEN_OPT_FORMAT" = 'btrfs' ] && sufi='vol0'

    # append "_root" and "_swap" suffixes
    case "$CEN_OPT_LABEL" in
    *_swap)     DAT_PART_LABEL="${CEN_OPT_LABEL%_*}_$sufi"
                DAT_SWAP_LABEL="${CEN_OPT_LABEL}"
                ;;
    *_*)        DAT_PART_LABEL="${CEN_OPT_LABEL}"
                DAT_SWAP_LABEL="${CEN_OPT_LABEL%_*}_swap"
                ;;
    *)          DAT_PART_LABEL="${CEN_OPT_LABEL}_$sufi"
                DAT_SWAP_LABEL="${CEN_OPT_LABEL}_swap"
    esac
}

# ------------------------------------------------------------------------------
# Get volume paths: <root> <user> <home> <boot>
# ------------------------------------------------------------------------------
do_locations() {
    local froot="${1:--}" fuser="${2:--}" fhome="${3:--}" fboot="${4:--}" \
          xhom='-' droo dest=()
    location -b "$DAT_DESTINATION" -f -d "$CEN_OPT_DIST" -m -s DAT_DEST_ROOT 'Root'
    case "${DAT_DEST_ROOT:--}" in
    -)                  error $"Missing 'Root' volume" ; return 1 ;;
    */Volumes/[A-Z]*)   droo="Volumes/${DAT_DEST_ROOT##*/}" ;;
    *)                  droo='.../' ; DAT_DEST_ROOT+='/'
                        xhom="${DAT_DEST_ROOT%/}/home"
    esac

    [ -z "${CEN_OPT_BOOT%[-+]}" ] && DAT_DEST_BOOT="${DAT_DEST_ROOT%/}/boot"
    DAT_DEST_USER="${DAT_DEST_ROOT%/}/usr"
    [ "$froot" = '-' ] || dest+=("$droo")
    [ "$fuser" = '-' ] || dest+=("${droo%/}/usr")

    if [ "$fhome" != '-' ] ; then
        location -b "$DAT_DESTINATION" -d "$CEN_OPT_DIST" -s DAT_DEST_HOME 'Home'
        [ "${DAT_DEST_HOME:--}" = '-' ] && DAT_DEST_HOME="$xhom"
        case "$DAT_DEST_HOME" in
        -)                  error $"Missing 'Home' volume" ; return 1 ;;
        */Volumes/[A-Z]*)   dest+=("Volumes/${DAT_DEST_HOME##*/}") ;;
        *)                  dest+=(".../${DAT_DEST_HOME##*/}")
        esac
    fi

    if [ "$fboot" != '-' ] ; then
    ### TODO --boot
    warning "[boot] only for dest=/"
        location -b "$DAT_DESTINATION" -d "$CEN_OPT_DIST" -s DAT_DEST_BOOT '[boot]'
        case "${DAT_DEST_BOOT,,}" in
        */efi)              dest+=("${DAT_DEST_BOOT##*/boot}image-$CEN_OPT_DIST") ;;
        *)                  warning $"Cannot find 'EFI' partition"
                            DAT_DEST_BOOT= ;;
        esac
    fi
    if [ -z "$dest" ] ; then
        error $"Nothing to restore" ; return 1
    fi
    message -h $"Volumes:" "${dest[@]//\/\//\/}" ; return 0
}

# ------------------------------------------------------------------------------
# generate a new machine id
# ------------------------------------------------------------------------------
do_machine_id() {
    system -w -c systemd-machine-id-setup || return
    remove -f 'etc/machine-id' 'var/lib/dbus/machine-id'
    system -p systemd-machine-id-setup --root=.
    symlink '/etc/machine-id' 'var/lib/dbus/machine-id'
}

# ------------------------------------------------------------------------------
# write a marker: <folder> <text>
# ------------------------------------------------------------------------------
do_marker() {
    local host="${CEN_OPT_CLONE:--}"
    [ "$host" = '-' ] && host="${DAT_PART_LABEL##*/}" && host="${host%%[_-]*}"
    [ -n "$host" ] || return
    [ -d "$1" ] || return
    local text="${2##*_}" ; [ -z "$text" ] && text='root'
    [ "$text" = 'root' ] && do_marker "$1/export" 'export'
    local mark="${host}_$text" ; mark="$1/${mark^^}"
    create -- "$mark" 700
    for text in "$1"/[A-Z]*_"${text^^}" ; do
        [ "$text" = "$mark" ] || remove -- "$text"
    done
}

# ------------------------------------------------------------------------------
# windows image: <file>
# ------------------------------------------------------------------------------
do_ntfsclone() {
    local xpnd path="$1" dest="$CEN_OPT_EXTRACT"
   # if [ "$
   # "$DAT_LOOPDEV"
    case "${path##*/}" in
    *.img)      ;;
    *.img.xz)   xpnd='xzcat' ;;
    *.img.gz)   xpnd='zcat' ;;
    *.img.bz2)  xpnd='bzcat' ;;
    *.img.lzo)  xpnd='lzop -cd' ;;
    *.img.lzma) xpnd='lzcat' ;;
    *.img.zstd) xpnd='zstdcat' ;;
    *.img.*)    quit -e $"Unknown image compression:" "$path" ;;
    *)          return 0
    esac

    [ "$#" = 1 ] || quit -e $"Extra arguments not allowed"
    do_chk_file path "$path" || return 1
    do_chk_block "$dest" || return 1

    confirm -a -f $"Restore '%s' from '%s' ..." "$dest" "${path##*/}" || quit -t

    # do an ntfs-image restore

    if [ -z "$xpnd" ] ; then
        system -e -g 0 -- ntfsclone --restore-image --overwrite "$dest" "$path"
    else
       system -e -c ${xpnd%% *} ntfsclone || return
       system -g 0 eval "$xpnd '$path' | ntfsclone --restore-image --overwrite '$dest'" -
       # syspipe -o "$xpnd $path" -d "ntfsclone --restore-image --overwrite $dest -"
    fi
    case "$?" in
    0)  return 1 ;;
    *)  quit -e $"Running 'ntfsclone' failed (status $?)"
    esac
    return 1
}

# ------------------------------------------------------------------------------
# make 6 char random string not starting with lower case letter
# ------------------------------------------------------------------------------
do_prefix() {
    [ -n "$DAT_PREFIX" ] && return
    local pref
    while : ; do
        read -r -N 16 pref </dev/urandom || fatal $"Cannot read:" '/dev/urandom'
        system -f -p -r -s pref base64 <<<$pref
        [ "${#pref}" -gt 10 ] && break
    done
    pref="${pref//[+\/]/%}"                         # + and / are not allowed
    pref="${pref:3:6}" ; DAT_PREFIX="${pref^}"
}

# ------------------------------------------------------------------------------
# rewrite a config file: <regx> <file>...
# ------------------------------------------------------------------------------
do_rewrite() {
    local expr="$1" fnam ; shift
    for fnam in "$@" ; do
        if dryrun -s ; then
            message -a -c $"Not rewriting" "$fnam"
        elif [ ! -r "$fnam" ] ; then
            warning $"Cannot rewrite:" "$fnam"
        elif [ -h "$fnam" -o -h "${fnam%/*}" ] ; then
            warning $"No rewrite via symlink:" "$fnam"
        else
            system -e -p sed --regexp-extended --in-place=".$CEN_NAME" \
                -e "$expr" "$fnam" && message -a -c $"Rewrote" "$fnam"
        fi
    done
}

# ------------------------------------------------------------------------------
# quit hook to unmount
# ------------------------------------------------------------------------------
do_unmount() {
    if [ -n "$DAT_LOOPDEV" ] ; then
        trace -c -a -p 'image file' $"Release '%s' ..." "$DAT_LOOPDEV"
        folder -c -f '/'
        system -q -r -- losetup -d "$DAT_LOOPDEV"
    fi
    $DAT_HOOK_QUIT "$@"
}

# ------------------------------------------------------------------------------
# restore a tar archive: <dest> <file> <opt>...
# ------------------------------------------------------------------------------
do_untar() {
    [ "${1:--}" = '-' ] && return 0                 # dest not specified
    [ "${2:--}" = '-' ] && return 0                 # file not specified
    local dest="$1" ; shift
    local file="$1" ; shift

    # get compression and archive type

    local compr='--auto-compress'
    case "$file" in
    *.tgz)      compr='--gzip' ;;
    *.tar.xz)   ;;
    *.tar.gz)   ;;
    *.tar.bz2)  ;;
    *.tar.lzo)  ;;
    *.tar.lzma) ;;
    *.tar.zstd) ;;
    *)          quit -e $"Unknown archive type or compression:" "$file" ;;
    esac

    # restore a tar-archive

    message -a -p $"Restore '%s' from '%s' ..." "$dest" "${file##*/}"
    local base="$PWD"
    folder -r -c -m -- "$dest"
    system -t -e tar -xf "$file" --overwrite --recursive-unlink $compr $DAT_TAR_OPTS "$@"
    [ "$DAT_DEST_ROOT" = "$dest" ] && do_fixup  # create required folders
    folder -r -c -- "$base"
    error -t || return 1

    # rename paths like "xxx/home/home" to "xxx/home"
    base="${dest##*/}"                          # gets 'home' or 'usr'
    if [ "$base" != 'home' -a "$base" != 'usr' ] ; then
        do_marker "$dest"
        error -t ; return                       # return status
    fi

    set -- "$dest"/*                            # may result on 'home' or 'usr'
    file="${dest##*/}" ; file="${file,}"        # lower case
    if [ "${1##*/}" = "$file" ] ; then          # needs to be renamed ...
        trace -i "Change '$1' to '$dest'"
        move -f -- "$1" "$dest.$$.$CEN_NAME"
        set -- "$dest.$$.$CEN_NAME"/*
        [ "${1##*/}" = '*' ] || move -f -- "$@" "$dest"
        set -- "$dest.$$.$CEN_NAME"/.[!.]*
        [ "${1##*/}" = '.[!.]*' ] || move -f -- "$@" "$dest"
        remove -d -- "$dest.$$.$CEN_NAME"
    fi
    [ "$base" != 'usr' ] && do_marker "$dest" "$base"
    error -t                                    # return status
}

# ------------------------------------------------------------------------------
# update grub and fstab: <boot> <root> <name>
# ------------------------------------------------------------------------------
do_update() {
    local dboot="${1:--}" droot="${2:--}" name="${3:--}" what=() list stab
    [ "$name" = '-' -o "$name" = '+' ] && return
    message -a -c "update" "bios: $dboot   root: $droot   name: %name"

    local stab svol='swap|vol0|vol1|archive|backup|shared|vbox|windows'

    # root:         <root-mpt>/etc/fstab
    # bios:         <boot-mpt>/grub/grub.cfg
    # grub:         <boot-mpt>/efi/grub/grub.cfg
    # loader:       <boot-mpt>/efi/loader/entries/*.conf
    # firmware:     <boot-mpt>/cmdline.txt cmdline-*.txt

    # --- etc/fstab ---

    # LABEL=xxxx_boot    ->  LABEL=${name}_boot   # (1) boot label
    # LABEL=bootfs       ->  LABEL=${name}_boot   # (3) raspberrypi legacy
    # PARTUUID=*-01      ->  LABEL=${name}_boot   # (3)

    # LABEL=xxxx_root    ->  LABEL=${name}_root   # (2) root label
    # LABEL=xxxx_($svol) ->  LABEL=${name}_...    # (2)
    # LABEL=rootfs       ->  LABEL=${name}_root   # (3)
    # PARTUUID=*-02      ->  LABEL=${name}_root   # (3)

    # UUID=* /           ->  LABEL=${name}_root
    # UUID=* none        ->  LABEL=${name}_swap

    if [ -f "$droot/etc/fstab" ] ; then
        stab="s/^(LABEL=[a-zA-Z0-9-]*_boot|LABEL=bootfs|PARTUUID=[a-zA-Z0-9]*-01)/LABEL=${name}_boot/g"
        stab+="; s/^(#?LABEL=)([a-zA-Z0-9-]*)_(root|$svol)/\1${name}_\3/g"
        stab+="; s/^(PARTUUID=[a-zA-Z0-9]*-02|LABEL=rootfs)/LABEL=${name}_root/g"
        stab+="; s/^(UUID=[-a-zA-Z0-9 ]*\/ )/LABEL=${name}_root \/ /g"
        stab+="; s/^(UUID=[-a-zA-Z0-9 ]*none )/LABEL=${name}_swap none /g"
        do_rewrite "$stab" "${droot%/}/etc/fstab"
    fi

    # --- cmdline.txt ---

    if [ -h "$dboot" ] ; then
        warning $"Should not be a symlink:" "$dboot" ; dboot='-'
    fi

    matchpath -f -a list -- "$dboot/cmdline.txt" "$dboot"/cmdline-*.txt
    local pref='root='
    stab="s/^$pref(#?LABEL=)([a-zA-Z0-9-]*)_(root|$svol)/${pref}\1${name}_\3/g"
    stab+="; s/^$pref(PARTUUID=[a-zA-Z0-9]*-02|LABEL=rootfs)/${pref}LABEL=${name}_root/g"
    do_rewrite "$stab" "${list[@]}"

    # --- grub.cfg ---

    matchpath -f -a list -- \
            "$droot/grub/grub.cfg" "$dboot/grub/grub.cfg" "$dboot"/[eE][fF][iI]/grub/grub.cfg
    stab="s/^set myname=.*/set myname=$name/"
    do_rewrite "$stab" "${list[@]}"

    # --- loader and UKI cmdlines ---

    matchpath -f -a list -- "$dboot/loader/entries"/*.conf "$dboot"/image*/cmdline
    stab="s/root=LABEL=[a-zA-Z0-9-]*_vol0/root=LABEL=${name}_vol0/"
    stab+="; s/resume=LABEL=[a-zA-Z0-9-]*_swap/resume=LABEL=${name}_swap/"
    do_rewrite "$stab" "${list[@]}"
}

# ------------------------------------------------------------------------------
# restore boot partition
# ------------------------------------------------------------------------------
run_boot() {
    [ "$CEN_OPT_BOOT" = '+' ] && return

    local fboot="$DAT_FILE_BOOT"
    if [ -z "$fboot" ] ; then
        if [ "${1:--}" = '-' ] ; then
            [ -n "$CEN_OPT_CLONE" ] && return 0
            nres=1
        else
            do_chk_file fboot "$1" || return
        fi
    fi

    if [ -z "$nres" ] ; then
        confirm -a -f $"Restore '%s' partition" "$CEN_OPT_BOOT" || quit -t
    fi
    do_destination "$CEN_OPT_BOOT" || return

    do_untar "$DAT_DESTINATION" "$fboot"
    do_clone "$DAT_DESTINATION"
}

# ------------------------------------------------------------------------------
# Rename running system
# ------------------------------------------------------------------------------
run_clone_old() {
    [ -n "$DAT_BOOT_CLONE" -o -n "$DAT_ROOT_CLONE" ] && return 0
    [ "$CEN_OPT_RESTORE" != '/' ] &&
        quit -e -p $"Use '%s' for\nan in-place rename of the running system" \
                   "$CEN_NAME -clone=$CEN_OPT_CLONE --restore=/"
    location -e -s DAT_DEST_BOOT '[boot]' || return
    do_clone "$DAT_DEST_BOOT" '/'

    [ "$CEN_OPT_RESTORE" != '/' ] &&
        quit -e -p $"Use '%s' for\nan in-place rename of the running system" \
                   "$CEN_NAME -clone=$CEN_OPT_CLONE --restore=/"
    do_destination "$CEN_OPT_RESTORE" || return
}

run_clone() {
    [ -n "$DAT_BOOT_CLONE" -o -n "$DAT_ROOT_CLONE" ] && return 0
    [ -z "$CEN_OPT_RESTORE" ] &&
        quit -e -p $"Use '%s' for\nan in-place rename of the running system" \
                   "$CEN_NAME -clone=$CEN_OPT_CLONE --restore=/"
    do_destination "$CEN_OPT_RESTORE" || return

    location -b "$DAT_DESTINATION" -f -d "$CEN_OPT_DIST" -m -s DAT_DEST_ROOT 'Root'
    if [ "${DAT_DEST_ROOT:--}" = '-' ] ; then
        error $"Missing 'Root' volume" ; return 1
    fi

    case "${CEN_OPT_BOOT:-+}" in
    -)  DAT_DEST_BOOT='-' ;;
    +)  location -b "$DAT_DESTINATION" -e -s DAT_DEST_BOOT '[boot]' || return ;;
    *)  folder "$CEN_OPT_BOOT" && DAT_DEST_BOOT="$CEN_OPT_BOOT" || return
    esac
    do_clone "$DAT_DEST_BOOT" "$DAT_DEST_ROOT"
}

# ------------------------------------------------------------------------------
# Extract extra archives
# ------------------------------------------------------------------------------
run_extract() {
    do_ntfsclone "$@" || return                     # handle windows image
    do_destination "$CEN_OPT_EXTRACT" || return

    local curr list=()
    for curr in "$@" ; do
        do_chk_file curr "$curr" && list+=("$curr")
    done
    error -t || return
    do_label "$curr"                                # init default label
    pluralize -s curr -- "${#list[@]}" $"file" $"files"
    confirm -a -f $"Restore %s to '%s'" "$curr" "$DAT_DESTINATION" || quit -t
    for curr in "${list[@]}" ; do
        do_untar "$DAT_DESTINATION" "$curr" || return
    done
}

# ------------------------------------------------------------------------------
# format partitions: [-f]
# ------------------------------------------------------------------------------
#   The -f option is used by run_part to handel formatting after partitioning
# ------------------------------------------------------------------------------
run_format() {
    if [ -n "$CEN_OPT_PART" ] ; then
        [ -n "$1" ] || return
    elif [ -z "$CEN_OPT_BOOT$CEN_OPT_GRUB$CEN_OPT_RESTORE$CEN_OPT_EXTRACT" ] ; then
        quit -e $"Option '--format' needs '--boot|--grub|--extract|--restore'"
    fi
    local par1="$CEN_OPT_BOOT"    par2="$CEN_OPT_RESTORE" \
          par3="$CEN_OPT_EXTRACT" parg="$CEN_OPT_GRUB"

    [ "$par2" = "$par3" ] && par3=
    [ "$par1" = "$par2" ] && par1=
    [ "$parg" = "$par1" ] && parg=
    [ "$parg" = "$par2" ] && parg=
    [ "$parg" = "$par3" ] && parg=

    case "$1" in
    *_*_*)  do_label "$1" ;;
    *)      do_label "$HOSTNAME"
    esac
    if [ -z "$DAT_FMT_VFAT" ] ; then
        par1= ; par2="$CEN_OPT_RESTORE" ; par3= ; parg=
    fi

    do_format "$par1" "$DAT_FMT_VFAT"   'boot'
    do_format "$par2" "$CEN_OPT_FORMAT" 'root'
    do_format "$par3" "$CEN_OPT_FORMAT" 'data'
    do_format "$parg" 'ext4'            'grub'
    error -t || return
    if [ -z "$1" ] ; then
        confirm $"WARNING formatting will override data. Continue anyhow" || quit -t
    fi
    do_format "$par1" "$DAT_FMT_VFAT"   'boot' + || return
    do_format "$par2" "$CEN_OPT_FORMAT" 'root' + || return
    do_format "$par3" "$CEN_OPT_FORMAT" 'data' + || return
    do_format "$parg" 'ext4'            'grub' +
}

# ------------------------------------------------------------------------------
# install bios grub
# ------------------------------------------------------------------------------
#   This does not install EFI grub, see centauriefilinux. Usually the EFI
#   partition will be restored from a backup. A minimal grub config gets
#   installed, see DAT_GRUB_MINIMAL.
# ------------------------------------------------------------------------------
run_grub() {
    [ "${CEN_OPT_GRUB:--}" = '-' ] && return
    do_destination "$CEN_OPT_GRUB" || return
    findmount -- "$DAT_DESTINATION" ||
        quit -e $"Found no device for mount-point:" "$DAT_DESTINATION"

    local gloc conf args

    if [ -d "$DAT_DESTINATION/dev" ] ; then     # root volume ...
        gloc='--root' ; conf="$DAT_DESTINATION/boot"
        remove -q "$conf"                       # remove potential symlink
        conf+='/grub'
        remove -q "$conf"                       # remove potential symlink
    else                                        # boot partition ...
        gloc='--boot' ; conf='grub'
        remove -q "$conf"                       # remove potential symlink
    fi
    remove -d "$conf" || return                 # remove potential folder
    folder -m "$conf" || return                 # (re-)create folder

    args=("$gloc-directory" "$DAT_DESTINATION")
    blkdevice -e -m -n 0 -- "$CEN_MOUNT_DEV" || return
    message -a -p $"Installing grub (%s) ..." "${args[*]}"
    system -e -p -- grub-install --target=i386-pc "${args[@]}" "$CEN_BLKDEVICE" || return

    if [ -e "$DAT_GRUB_MINIMAL" ] ; then
        copy "$DAT_GRUB_MINIMAL" "$conf/grub.cfg"
        do_update "$DAT_DESTINATION"
    fi

    # TODO --format /dev ends up in /mnt
}

# ------------------------------------------------------------------------------
#
# ------------------------------------------------------------------------------
run_image() {
    system -e -p -r -s DAT_LOOPDEV -- losetup --partscan --show --find "$CEN_OPT_IMAGE" || return
    context -h CEN_HOOK_QUIT DAT_HOOK_QUIT 'do_unmount'
    local item part dest
    for item in BOOT GRUB EXTRACT SWAP RESTORE PART ; do
        eval dest=\$CEN_OPT_$item
        case "${dest:--}" in
        /img)   part="$DAT_LOOPDEV"
                trace -a -c "image device" "$item=$part"
                printf -v "CEN_OPT_$item" '%s' "$part" ;;
        /img/?) part="${DAT_LOOPDEV}p${dest:5}"
                [ -e "$part" ] || quit -e $"Partion not found in image:" "$dest"
                trace -a -c "image partition" "$item=$part"
                printf -v "CEN_OPT_$item" '%s' "$part" ;;
        -)      ;;
        *)      quit -e $"Invalid image reference:" "$dest"
        esac
    done
}

# ------------------------------------------------------------------------------
# partitioning: --part=<disk> <type> [<swap>]
#
# Arguments:    <disk>  drive-device or loop-device
#               <type>  partitioning sheme:
#                       msdos   dos-table, bios boot [swap] root partition
#                       gpt     gpt-table, bios boot [swap] root partition
#                       efi     gpt-table,  efi-boot [swap] root partition
#               <swap>  swap size <size>M|<size>G (no swap if missing)
# ------------------------------------------------------------------------------
run_part() {
    local mode="$1" disk="$CEN_OPT_PART" swap="${2:--}" args=() part mksw

    case "${disk##*/}" in
    sd?|hd?)    part="$disk" ;;
    *)          part="${disk}p"
    esac

    case "${swap##*[0-9]}" in
    -)      mode+='-' ;;                            # no swap
    g|G)    swap="${swap%?}" ; ((swap *= 1024)) ;;
    m|M)    swap="${swap%?}" ;;
    *)      invoke -a 2 "<size>M|<size>G" ; return
    esac
    CEN_OPT_BOOT="${part}1" ; CEN_OPT_RESTORE="${part}3"

    case "$mode" in
    gpt)    mode='gpt' ; ((swap += 640))
            args+=( mkpart _part0 0% 512MiB
                    mkpart _part1 512MiB 640MiB
                    mkpart _part2 640MiB ${swap}MiB
                    mkpart _part3 ${swap}MiB 100%
                    set 1 esp on set 2 bios_grub on
                  )
            mksw="${part}3" ; CEN_OPT_RESTORE="${part}4"
            message -a -c $"partitioning" "boot=${part}1  swap=${part}3  root=${part}4"
                  ;;
    gpt-)   mode='gpt'
            args+=( mkpart _part0 0% 512MiB
                    mkpart _part1 512MiB 640MiB
                    mkpart _part2 640MiB 100%
                    set 1 esp on set 2 bios_grub on
                  )
             message -a -c $"partitioning" "boot=${part}1  root=${part}3"
             ;;
    efi)    mode='gpt' ; ((swap += 512))
            args+=( mkpart _part0 0% 512MiB
                    mkpart _part1 512MiB ${swap}MiB
                    mkpart _part2 ${swap}MiB 100%
                    set 1 esp on
                  )
            mksw="${part}2"
            message -a -c $"partitioning" "boot=${part}1  swap=${part}2  root=${part}3"
            ;;
    efi-)   mode='gpt'
            args+=( mkpart _part0 0% 512MiB
                    mkpart _part1 512MiB 100%
                    set 1 esp on
                  )
            CEN_OPT_RESTORE="${part}2"
            message -a -c $"partitioning" "boot=${part}1  root=${part}2"
            ;;
    msdos)  mode='msdos' ; ((swap += 128))
            args+=( mkpart primary 0% 128MiB
                    mkpart primary 128MiB ${swap}MiB
                    mkpart primary ${swap}MiB 100%
                    set 1 boot on
                  )
            mksw="${part}2"
            message -a -c $"partitioning" "boot=${part}1  swap=${part}2  root=${part}3"
            ;;
    msdos-) mode='msdos'
            args+=( mkpart primary 0% 128MiB
                    mkpart primary 128MiB 100%
                    set 1 boot on
                  )
            CEN_OPT_RESTORE="${part}2"
            message -a -c $"partitioning" "boot=${part}1  root=${part}2"
            ;;
    data-)  mode='msdos'
            args+=( mkpart primary 0% 100%
                    set 1 boot on
                  )
            CEN_OPT_BOOT=
            DAT_FMT_VFAT= ; [ -z "$CEN_OPT_FORMAT" ] && CEN_OPT_FORMAT='exfat'
            message -a -c $"partitioning" "data=${part}1"
            ;;
    *)      invoke -a 1 'efi|gpt|msdos|data' ; return
    esac

    do_chk_block "$disk" || return
    confirm $"WARNING partitioning will override all data. Continue anyhow" || quit -t

    system -e -p -g 0 -- dd if=/dev/zero of="$disk" bs=1M count=32 || return
    system -e -p -g 0 -- parted --script -a optimal "$disk" mklabel "$mode" "${args[@]}" || return

    # done if not formatting and no implied swap creation
    if [ -z "$CEN_OPT_FORMAT" ] ; then
        [ -z "$mksw" -o -n "$CEN_OPT_SWAP" ] && return
    fi

    # must reload partion info for format or swap
    if [ -n "$CEN_OPT_IMAGE" ] ; then
        system -q -r -- losetup -d "$DAT_LOOPDEV" || return
        mksw="${mksw#$DAT_LOOPDEV}"
        timer -w 0.3
        system -e -p -r -s DAT_LOOPDEV -- \
               losetup --partscan --show --find "$CEN_OPT_IMAGE" || return
        [ -n "$mksw" ] && CEN_OPT_SWAP="$DAT_LOOPDEV$mksw"
        [ -z "$DAT_FMT_VFAT" ] && CEN_OPT_RESTORE='/img/1'
    else
        system -e -p -r -- partprobe "$disk" || return
        timer -w 0.5
        [ -n "$mksw" ] && CEN_OPT_SWAP="$mksw"
        [ -z "$DAT_FMT_VFAT" ] && CEN_OPT_RESTORE="${part}1"
    fi

    [ -n "$CEN_OPT_SWAP" ] && run_swap -f
    [ -n "$CEN_OPT_FORMAT" ] && run_format -f
}

# ------------------------------------------------------------------------------
#
# ------------------------------------------------------------------------------
run_restore() {
    do_destination "$CEN_OPT_RESTORE" || return

    # get file template from 1st name found
    local item fname froot fuser fhome fboot
    for item in "$@" ; do
        [[ "$item" =~ (.*/)?(.*_)?(boot|root|home|usr)(_.*|\..*) ]] || continue
        fname="${BASH_REMATCH[1]}${BASH_REMATCH[2]}::::${BASH_REMATCH[4]}" ; break
    done

    # get the tar file names
    item=
    do_chk_file froot "$1" 'root' "$fname" && item+=' root'
    do_chk_file fuser "$2" 'usr'  "$fname" && item+=' usr'
    do_chk_file fhome "$3" 'home' "$fname" && item+=' home'
    [ -n "$CEN_OPT_DIST" -o -n "$CEN_OPT_BOOT" ] &&
        do_chk_file fboot "$4" 'boot' "$fname" && item+=' boot'
    error -q
    if [ -z "$item" ] ; then
        [ -z "$CEN_OPT_CLONE" ] && item='message' || item='trace'
        $item -a $"Nothing to restore" ; return
    else
        message -a $"System restore:" "$item"
    fi

    # option --dist, create volumes
    if [ -n "$CEN_OPT_DIST" ] ; then
        local vols="$DAT_DESTINATION/mnt/vol0/Volumes" crea=()
        [ ! -d "$vols" ] && vols="$DAT_DESTINATION/Volumes"
        [ ! -d "$vols" ] &&
            quit -e -p $"Found no '%s' (%s)" "$vols" $"no btrfs?"
        [ -d "$vols/Root-$CEN_OPT_DIST" ] || crea+=("$vols/Root-$CEN_OPT_DIST")
        [ -d "$vols/Home-$CEN_OPT_DIST" ] || crea+=("$vols/Home-$CEN_OPT_DIST")
        if [ -n "$crea" ] ; then
            confirm $"Create btrfs subvolumes " || quit -t
            for item in "${crea[@]}" ; do
                system -e -p -g 0 -- btrfs subvolume create "$item" || return
            done
        fi
    fi

    if [ -n "$CEN_OPT_BOOT" ] ; then                # see run_boot
         DAT_FILE_BOOT="$fboot" ; fboot=
    elif [ "$DAT_DESTINATION" != '/' ] ; then       # boot needs EFI mount
        fboot=
    fi
    do_locations "$froot" "$fuser" "$fhome" "$fboot"
    error -t || return
    confirm -a -f $"Restore data to '%s'" "$DAT_DESTINATION" || quit -t

    # --- restore root ---

    do_untar "$DAT_DEST_ROOT" "$froot" \
        '--exclude=./boot/grub/locale'  \
        '--exclude=./boot/grub/fonts'   \
        '--exclude=./boot/grub/i386-pc' \
        '--exclude=./boot/grub/x86_64-efi' \
        '--exclude=./boot/grub/grubenv' \
        '--exclude=./boot/grub/*~'      \
        '--exclude=./boot/grub/*.o'     \
        '--exclude=./boot/grub/*.img'   \
        '--exclude=./boot/grub/*.pf2'   \
        '--exclude=./boot/grub/*.mod'   \
        '--exclude=./boot/grub/*.lst' || return

    # --- restore usr and home ---

    do_untar "$DAT_DEST_USER" "$fuser" || return
    do_untar "$DAT_DEST_HOME" "$fhome" || return
    # this is only for the current system where EFI is mounted
    do_untar "${DAT_DEST_BOOT%/*}" "$fboot" "./image-$CEN_OPT_DIST" || return

    message -a $"Waiting for queued disk writes to complete..."
    system -e -p -g 0 -- sync || return
    do_clone "$DAT_DEST_BOOT" "$DAT_DEST_ROOT"
}

# ------------------------------------------------------------------------------
# Create swap file-system: [-f]
# ------------------------------------------------------------------------------
run_swap() {
    [ "${CEN_OPT_SWAP:--}" = '-' ] && return
    do_chk_block "$CEN_OPT_SWAP" || return
    do_label "$HOSTNAME"
    [ -n "$DAT_SWAP_LABEL" ] &&
        message -a -p $"Will label swap partition as: %s" "$DAT_SWAP_LABEL"

    if [ "$1" != '-f' ] ; then
        confirm -a -f $"Create swap space on '%s'" "$CEN_OPT_SWAP" || quit -t
    fi
    if [ -z "$DAT_SWAP_LABEL" ] ; then
        system -f -p mkswap "$CEN_OPT_SWAP"
    else
        system -f -p mkswap -L "$DAT_SWAP_LABEL" "$CEN_OPT_SWAP"
    fi
}

# ------------------------------------------------------------------------------
# Option parsing
# ------------------------------------------------------------------------------
options() {
    case "$CEN_ACTION" in

    -2|--f2f|--f2fs)
        optarg 'format'     -   - 'f2fs' ;;
    -4|--ext|--ext4)
        optarg 'format'     -   - 'ext4' ;;
    -B|--boo|--boot)
        optarg 'boot'       -   -t ;;
    -C|--clo*)
        optarg 'clone'      -   -h ;;
    -D|--dis*)
        optarg 'dist'       -   '[^/ ]*' ;;
    -F|--for*|--fmt)
        optarg 'format'     -   - 'btrfs' ;;
    -G|--gru*)
        optarg 'grub'       -   -t ;;
    -I|--ima*)
        optarg 'image'      -   -t ;;
    -L|--lab*)
        optarg 'label'      -   -h ;;
    -P|--par*)
        optarg 'partition'  CEN_OPT_PART -t ;;
    -R|--res*)
        optarg 'restore'    -   -t ;;
    -S|--swa*)
        optarg 'swap'       -   -t ;;
    -X|--ext*)
        optarg 'extract'    -   -t ;;

    # after option processing
    '')
        # restore|image|xtract are mutually exclusive
        [ -n "$CEN_OPT_RESTORE" ] && dispatch -m 'restore' 1 .
        [ -n "$CEN_OPT_EXTRACT" ] && dispatch -m 'extract' 1 +
        [ -n "$CEN_OPT_PART" ]    && dispatch -m 'part'    1 2

        # special, run before main action
        [ -n "$CEN_OPT_IMAGE" ]   && dispatch -s 'image'   0 -
        [ -n "$CEN_OPT_FORMAT" ]  && dispatch -s 'format'  0 -

        # will run 1st seen
        [ -n "$CEN_OPT_BOOT" ]    && dispatch    'boot'    1 -
        [ -n "$CEN_OPT_GRUB" ]    && dispatch    'grub'    0 -
        [ -n "$CEN_OPT_CLONE" ]   && dispatch    'clone'   0 -
        [ -n "$CEN_OPT_SWAP" ]    && dispatch    'swap'    0 -
    esac
}

# ------------------------------------------------------------------------------
# dispatch main action: [-m] <name> <min> <max> <arg>...
#
#       centaurestore always executes exactly one main action run_<name> or
#       if run_default. This uses 'CEN_HOOK_ACTIONS' to call 'dispatch -r'
#       when main() executes run().
# ------------------------------------------------------------------------------
DAT_DISPATCH_FRST=()
DAT_DISPATCH_SCND=()
dispatch() {
    # this is called from CEN_HOOK_ACTIONS to run a main action
    if [ "$1" = '-r' ] ; then
        if [ -z "$DAT_DISPATCH" -a -z "$DAT_DISPATCH_FRST" ] ; then
            error -r -p -z $"Don't know what to do, try '%q --help'" "$CEN_NAME"
        else
            shift                                   # remove -r
            context -r -t +                         # root only, trap handler
            umask 22                                # create dirs with 0x755
            local disp optv
            for disp in "${DAT_DISPATCH_FRST[@]}" "$DAT_DISPATCH" \
                        "${DAT_DISPATCH_SCND[@]}" ; do
                error -q
                eval optv="\$CEN_OPT_${disp^^}"
                [ -n "$optv" ] && invoke "$disp" "run_$disp" "$@"
            done
        fi
        quit

    # mutually exclusive actions
    elif [ "$1" = '-m' ] ; then
        [ -n "$DAT_DISPATCH" ] &&
            quit -e -p $"Cannot combine options '--%s' and '--%s'" "$2" "$DAT_DISPATCH"
        shift
    elif [ "$1" = '-s' ] ; then
        DAT_DISPATCH_FRST+=("$2") ; return
    elif [ -n "$DAT_DISPATCH" ] ; then
        DAT_DISPATCH_SCND+=("$1") ; return
    fi

    # register the 1st action seen
    DAT_DISPATCH="$1"
    CEN_RUN_MIN_ARGS="$2"
    if [ "$3" = '.' ] ; then
        [ -n "$CEN_OPT_CLONE" ] && CEN_RUN_MIN_ARGS=0
        [ -z "$CEN_OPT_DIST" ] && CEN_RUN_MAX_ARGS=3 || CEN_RUN_MAX_ARGS=4
    else
        CEN_RUN_MAX_ARGS="$3"
    fi
}

# ------------------------------------------------------------------------------
# print usage info
#
# $CEN_NAME -B /dev/sdb1 -R /dev/sdb4 root.tgz usr.tgz home.tgz boot.tgz
# $CEN_NAME -B /dev/sdb1 -R /dev/sdb4 root.tgz
# $CEN_NAME -B /dev/sdb1 -R /dev/sdb4 root.tgz -C newname
# $CEN_NAME -B /dev/sdb1 boot.tgz
#
# $CEN_NAME -X /dev/sdb4 export.tgz shared.txz
#
# $CEN_NAME -F /dev/sdb1 -G /dev/sdb1 -R + root.tgz
#
# $CEN_NAME -B /dev/sdb1 -R /dev/sdb4 root.tgz -C newname
# ------------------------------------------------------------------------------
usage() {
    usagecat << !EOF
usage: (1) $CEN_NAME <option>... --partition /dev/<disk> <kind> [<swap>]
       °   $CEN_NAME <option>... --partition /img --image <file> <kind> [<swap>]
       (2) $CEN_NAME <option>... --restore /dev/<part> <root> [<usr> [<home> [<boot>]]]
       °   $CEN_NAME <option>... --restore /img/<indx> --image <file> <root> ...
       (3) $CEN_NAME <option>... --extract /dev/<part> <arch>...
       °   $CEN_NAME <option>... --extract /img/<indx> --image <file> <arch> ...

       $CEN_TITLE.

$CEN_USE_OPTIONS

       ••• main options (required, mutually exclusive) •••

       -P --partition       disk partitioning
       -R --restore         restore system backup
       -X --extract         extract archive(s) to disk

       ••• additional options •••

       -F --format          make 'btrfs' filesystem
       -2 --fs2fs           (instead of --format) make 'f2fs' filesystem
       -4 --ext4            (instead of --format) make 'ext4' filesystem

       -B --boot    <dest>  restore EFI boot partition
       -C --clone   <name>  clone/rename system with hostname=<name>
       -D --dist    <nick>  add distribution name to root/home btrfs-volumes
       -G --grub            run BIOS grub-install (i386-pc target)
       -I --image   <file>  restore to an image file
       -L --label   <text>  override partition label    (- for no label)
       -S --swap    <part>  create a swap partition

arguments:
       <dest>               partition: /dev/<part>  -or- image: /img/<indx>
       <part>               a partition name            (example: "sda3")
       <indx>               partion number in image     (1, 2, ...)
       <disk>               a block device              (example: "nvme0n1")

       <arch>               a tar archive <file>, can be compressed
       <root>               system root <arch>  -or-  "-" to skip
       <usr>                system usr  <arch>  -or-  "-" to skip
       °                                <>      -or-  "+" automatic file path
       <home>               system home <arch>  -or-  "-"   -or-  "+"
       <boot>               system boot <arch>  -or-  "-"   -or-  "+"

       $CEN_NAME [options...] -|<root> [-|+|<user> [-|+|<home>]]

       <file>               a file path
       <fldr>               a folder path
       <name>               a host name or '-' (from label) or '+' (fixup only)
       <nick>               nick name suffix  -or- '-' for current distribution
       <part>               a partition name or path
       <text>               volume label text
       <root>               tar-file with root data (excludes /home and /usr)
       <user> <home>        tar-file with /usr or /home, + generates from <root>

       When a - placeholder is used for a tar-file, the file is skipped. By
       default the label name is derived from the --clone name or the archive name.

examples:
       (1) $CEN_NAME -F -G -P sda1 mysys_root_2012-07-21.tgz
       (2) $CEN_NAME -F -G -P sda1 -C yoursys mysys_root_2012-07-21.tgz
       (3) $CEN_NAME -A sdb1 -S sdb2 jessie4_root_2015-07-13.tgz

       (4) $CEN_NAME -R /export mysys_export_2012-07-21.tgz
       (5) $CEN_NAME -M /mnt/xxx/ -C yoursys xxx_root_2019-05-05.tgz + -

       (6) $CEN_NAME -R / -C yoursys
       (7) $CEN_NAME -R /mnt/xxx -C +
       (8) $CEN_NAME -R /mnt/xxx -C yoursys -C - -C - -C /mnt/yyy/grub

       (9)  $CEN_NAME -B /mnt/yyy -C yoursys mysys_boot_2022-05-02.tgz
       (10) $CEN_NAME -G -P sda1 -

For (1) a mount-point /mnt/sda1 is created, /dev/sda1 is formatted and labeled
'mysys_root'. The usr and home tgz files are automatically used.  For case (2)
or (3) the machine is renamed as needed (see: centaurinetcfg setup).

Form (4) restores a backup to the actual machine. In case (5) root and user are
restored but home is left unmodified.

Form (6) renames the actual machine. (7) should be used after a manual untar to
fixup some devices, folders and the machine-id. (8) does not change fstab and
passes the base folder of grub.cfg.

An EFI boot partition is restored using form (9). The BIOS version of grub can
be installed using form (10).
!EOF

    usagecat -v "more:  Use -- for partition and sub-volume information." << !EOF

mount:  Traditionally Linux used partitions to keep data seperate and mounted these
        at some well known locations (mount points). Some newer file systems (like
        btrfs) can create logical sub-volumes in formatted partitions. These can be
        mounted like partitions.

        centauri-tools identify volumes by file-system labels (see below) for more
        portability. This contrasts with most linux distros that are using UUIDs.


volume: centauri-tools use partions and/or (sub-)volumes. Formatted partions and
        sub-volumes are called volumes and have assigned a traditional name (in
        uppercase).

    Name    mount      fstab  Purpose  Export  Description
    ------- ---------- ------ -------- ------- --------------------------------
    ROOT    /          yes    system   no      contains the operatings system
    BOOT    /boot/efi  (yes)  boot     no      stuff needed for booting
    HOME    /home      (yes)  private  server  data belonging to users
    EXPORT  /export    no     public   yes     world readable data
    SHARED  /shared    no     shared   yes     data belonging to user groups
    BACKUP  /backup    no     backup   no      space to store backup data
    DATA    /data      no     data     optinal extra data, no specific purpose
    SWAP    -          (no)   swap     no      swap space for transient data
    ------- ----------- -------- ------- --------------------------------------

fstab:  The tradional mount table contains only entries that are not handled by
        either systemd nor centaurimounter. BOOT and HOME are usually added to
        fstab as a fall-back. SWAP partions are not added (detected by systemd).
        Swap-files not added either, they would be handled by centauriswap.

label:  The centauri-tools handle some pre-defined partitions. These have file-
        system labels assigned and are mounted via fstab or centaurimounter. The
        labels get updated by $CEN_NAME on restore or rename. $CEN_NAME
        also updates grub.cfg, systemd boot, raspberrypi boot and /etc/fstab.

    Label          § Type     Mand    Description
    -------------- § -------- ------- ------------------------
    <host>_ROOT    § ext4     yes     only if not using btrfs
    <host>_BOOT    § vfat     (yes)   only for efi or firmware
    <host>_VOL0    § btrfs    yes     only used with btrfs
    <host>_VOL<n>  § btrfs    no      additional physical volumes
    <host>_SWAP    § swao     no      transient data
    <host>_DATA    § any      no      extra
    -------------- § -------- ------- ------------------------
!EOF

}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
